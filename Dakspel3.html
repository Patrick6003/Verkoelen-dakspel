<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dak Runner - Verkoelen Dakspecialisten Weert</title>
    <style>
        body { margin: 0; overflow: hidden; background: linear-gradient(#D3D3D3, #FFFFFF); }
        canvas { display: block; margin: 0 auto; border: 1px solid #FF6600; }
        #score { position: absolute; top: 10px; left: 10px; font-family: Arial; font-size: 24px; color: #FF6600; }
        #money { position: absolute; top: 10px; right: 10px; font-family: Arial; font-size: 24px; color: #FF6600; }
        #game-over { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-family: Arial; font-size: 32px; color: #FF6600; display: none; text-align: center; background: rgba(255, 255, 255, 0.8); padding: 20px; border-radius: 10px; box-shadow: 0 0 10px #D3D3D3; }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="score">Score: 0</div>
    <div id="money">Geld: €0</div>
    <div id="game-over">
        Game Over!<br>
        Score: <span id="final-score">0</span><br>
        Geld: €<span id="final-money">0</span><br>
        Hoogste Score: <span id="high-score">0</span><br>
        Verkoelen Dakspecialisten: Bereik Nieuwe Hoogtes!<br>
        Bezoek www.verkoelen.nl voor uw dakbehoeften.<br>
        Druk op spatie of tik om te herstarten.
    </div>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 800;
        canvas.height = 600;

        // Huisstijl kleuren
        const ORANGE = '#FF6600';
        const LIGHT_GRAY = '#D3D3D3';
        const WHITE = '#FFFFFF';
        const DARK_GRAY = '#A9A9A9';
        const BRICK_RED = '#CD853F';
        const OVERALL_BLUE = '#0066CC';

        // Speler
        let player = {
            x: 100,
            y: canvas.height - 120,
            width: 40,
            height: 60,
            velocityY: 0,
            gravity: 0.8,
            jumpForce: -22, // Verhoogd voor hogere sprong
            isJumping: false,
            animationFrame: 0,
            jetpackActive: false,
            jetpackTimer: 0,
            isFalling: false // Nieuw voor gap detectie
        };

        // Grond
        let groundY = canvas.height - 50;
        let groundOffset = 0;
        let speed = 5;

        // Obstakels en items
        let obstacles = [];
        let items = [];
        let obstacleSpawnRate = 100;
        let frameCount = 0;

        // Achtergrond (meer realistische lucht met extra wolkenlagen)
        let bgCloudsNear = []; // Snellere wolken
        let bgCloudsFar = []; // Langzamere wolken
        for (let i = 0; i < 5; i++) {
            bgCloudsNear.push({ x: Math.random() * canvas.width, y: Math.random() * 150 + 100, size: Math.random() * 40 + 30, speed: speed / 1.5 });
            bgCloudsFar.push({ x: Math.random() * canvas.width, y: Math.random() * 100 + 50, size: Math.random() * 60 + 40, speed: speed / 3 });
        }

        // Score, geld en state
        let score = 0;
        let money = 0;
        let highScore = 0;
        let gameOver = false;

        // Genereer obstakel
        function generateObstacle() {
            let type = Math.random() > 0.5 ? 'chimney' : 'gap';
            let obs = {
                x: canvas.width,
                y: groundY - (type === 'chimney' ? 60 : 0),
                width: type === 'chimney' ? 40 : 80,
                height: type === 'chimney' ? 60 : 20,
                type: type
            };
            obstacles.push(obs);
        }

        // Genereer item
        function generateItem() {
            let type = Math.random() > 0.8 ? 'jetpack' : 'money';
            let item = {
                x: canvas.width + Math.random() * 200,
                y: groundY - 80 - Math.random() * 50,
                size: 20,
                type: type,
                collected: false
            };
            items.push(item);
        }

        // Teken achtergrond (realistischer met meerdere lagen en zachte gradients)
        function drawBackground() {
            let gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#87CEEB'); // Lichtere blauwe lucht bovenaan
            gradient.addColorStop(0.3, WHITE);
            gradient.addColorStop(1, LIGHT_GRAY);
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Verre wolken (langzamer, groter)
            bgCloudsFar.forEach(cloud => {
                ctx.fillStyle = 'rgba(255,255,255,0.8)';
                ctx.beginPath();
                ctx.arc(cloud.x, cloud.y, cloud.size / 2, 0, Math.PI * 2);
                ctx.arc(cloud.x + cloud.size / 3, cloud.y - cloud.size / 4, cloud.size / 3, 0, Math.PI * 2);
                ctx.arc(cloud.x - cloud.size / 3, cloud.y - cloud.size / 4, cloud.size / 3, 0, Math.PI * 2);
                ctx.fill();
                cloud.x -= cloud.speed;
                if (cloud.x < -cloud.size) cloud.x = canvas.width + cloud.size;
            });

            // Nabije wolken (sneller, kleiner)
            bgCloudsNear.forEach(cloud => {
                ctx.fillStyle = WHITE;
                ctx.beginPath();
                ctx.arc(cloud.x, cloud.y, cloud.size / 2, 0, Math.PI * 2);
                ctx.arc(cloud.x + cloud.size / 3, cloud.y - cloud.size / 4, cloud.size / 3, 0, Math.PI * 2);
                ctx.arc(cloud.x - cloud.size / 3, cloud.y - cloud.size / 4, cloud.size / 3, 0, Math.PI * 2);
                ctx.fill();
                cloud.x -= cloud.speed;
                if (cloud.x < -cloud.size) cloud.x = canvas.width + cloud.size;
            });
        }

        // Teken grond met dakpannen-motief en gaps als scheuren
        function drawGround() {
            ctx.fillStyle = DARK_GRAY;
            ctx.fillRect(0, groundY, canvas.width, canvas.height - groundY);

            // Dakpannen-motief (scrollend met dezelfde speed als obstakels)
            groundOffset -= speed;
            if (groundOffset <= -40) groundOffset = 0;
            for (let x = groundOffset; x < canvas.width + 40; x += 40) {
                for (let row = 0; row < 3; row++) {
                    let panY = groundY - row * 15;
                    let panOffset = (row % 2) * 20;
                    ctx.fillStyle = ORANGE;
                    ctx.fillRect(x + panOffset, panY, 35, 15);
                    ctx.fillStyle = 'rgba(0,0,0,0.2)';
                    ctx.fillRect(x + panOffset + 2, panY + 2, 35, 5);
                }
            }

            // Gaten als grote scheuren (jagged edges)
            obstacles.forEach(obs => {
                if (obs.type === 'gap' && obs.x + obs.width > 0 && obs.x < canvas.width) {
                    ctx.fillStyle = '#000000';
                    ctx.beginPath();
                    ctx.moveTo(obs.x, groundY - 20);
                    // Jagged top edge voor scheur
                    for (let i = 0; i < obs.width; i += 10) {
                        ctx.lineTo(obs.x + i, groundY - 20 - Math.random() * 10 + 5);
                    }
                    ctx.lineTo(obs.x + obs.width, groundY - 20);
                    ctx.lineTo(obs.x + obs.width, canvas.height);
                    ctx.lineTo(obs.x, canvas.height);
                    ctx.closePath();
                    ctx.fill();
                    // Donkere randen voor diepte
                    ctx.strokeStyle = '#333333';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                }
            });
        }

        // Teken speler
        function drawPlayer() {
            player.animationFrame += 0.3;
            let armSwing = Math.sin(player.animationFrame) * 10;
            let legSwing = Math.sin(player.animationFrame + Math.PI) * 8;

            ctx.shadowColor = 'rgba(0,0,0,0.3)';
            ctx.shadowBlur = 5;
            ctx.shadowOffsetX = 2;
            ctx.shadowOffsetY = 2;

            // Hoofd, helm, etc. (zelfde als voorheen)
            ctx.fillStyle = '#FDBCB4';
            ctx.beginPath();
            ctx.arc(player.x + player.width / 2, player.y + 10, 12, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = WHITE;
            ctx.beginPath();
            ctx.arc(player.x + player.width / 2, player.y + 5, 15, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(player.x + player.width / 2 - 4, player.y + 8, 2, 0, Math.PI * 2);
            ctx.arc(player.x + player.width / 2 + 4, player.y + 8, 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#000';
            ctx.fillRect(player.x + player.width / 2 - 6, player.y + 15, 12, 3);

            ctx.fillStyle = OVERALL_BLUE;
            ctx.fillRect(player.x + 5, player.y + 20, player.width - 10, 25);

            ctx.fillStyle = OVERALL_BLUE;
            ctx.save();
            ctx.translate(player.x + 5, player.y + 25);
            ctx.rotate(armSwing * Math.PI / 180);
            ctx.fillRect(0, 0, 8, 15);
            ctx.restore();
            ctx.save();
            ctx.translate(player.x + player.width - 5, player.y + 25);
            ctx.rotate(-armSwing * Math.PI / 180);
            ctx.fillRect(-8, 0, 8, 15);
            ctx.restore();

            ctx.fillStyle = OVERALL_BLUE;
            ctx.save();
            ctx.translate(player.x + 10, player.y + 45);
            ctx.rotate(legSwing * Math.PI / 180);
            ctx.fillRect(0, 0, 8, 15);
            ctx.restore();
            ctx.save();
            ctx.translate(player.x + player.width - 10, player.y + 45);
            ctx.rotate(-legSwing * Math.PI / 180);
            ctx.fillRect(0, 0, 8, 15);
            ctx.restore();

            if (player.jetpackActive) {
                ctx.fillStyle = ORANGE;
                for (let i = 0; i < 3; i++) {
                    ctx.beginPath();
                    ctx.arc(player.x + player.width / 2, player.y + player.height + 5 + i * 3, 3 + Math.random() * 5, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            ctx.shadowColor = 'transparent';
        }

        // Teken obstakels
        function drawObstacles() {
            obstacles.forEach(obs => {
                if (obs.type === 'chimney') {
                    ctx.fillStyle = LIGHT_GRAY;
                    ctx.fillRect(obs.x, obs.y, obs.width, obs.height);
                    for (let by = obs.y; by < obs.y + obs.height; by += 10) {
                        for (let bx = obs.x; bx < obs.x + obs.width; bx += 8) {
                            let brickOffset = (Math.floor(by / 10) % 2) * 4;
                            ctx.fillStyle = BRICK_RED;
                            ctx.fillRect(bx + brickOffset, by, 8, 8);
                            ctx.strokeStyle = DARK_GRAY;
                            ctx.lineWidth = 1;
                            ctx.strokeRect(bx + brickOffset, by, 8, 8);
                        }
                    }
                    ctx.fillStyle = DARK_GRAY;
                    ctx.fillRect(obs.x - 5, obs.y - 10, obs.width + 10, 10);
                }
            });
        }

        // Teken items
        function drawItems() {
            items.forEach(item => {
                if (!item.collected) {
                    if (item.type === 'money') {
                        ctx.fillStyle = ORANGE;
                        ctx.fillRect(item.x, item.y, item.size, item.size / 2);
                        ctx.fillStyle = 'rgba(0,0,0,0.3)';
                        ctx.fillRect(item.x + 2, item.y + 2, item.size, item.size / 2);
                        ctx.fillStyle = WHITE;
                        ctx.font = 'bold 12px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText('$', item.x + item.size / 2, item.y + item.size / 3 + 4);
                    } else if (item.type === 'jetpack') {
                        ctx.fillStyle = ORANGE;
                        ctx.beginPath();
                        ctx.moveTo(item.x + item.size / 2, item.y);
                        ctx.lineTo(item.x, item.y + item.size);
                        ctx.lineTo(item.x + item.size, item.y + item.size);
                        ctx.closePath();
                        ctx.fill();
                        ctx.fillStyle = 'rgba(255,255,255,0.5)';
                        ctx.fillRect(item.x + 5, item.y + 5, item.size - 10, 5);
                    }
                }
            });
        }

        // Update
        function update() {
            if (gameOver) return;

            frameCount++;
            speed = 5 + score / 1000;

            // Update wolken speeds (voor consistentie)
            bgCloudsNear.forEach(cloud => cloud.speed = speed / 1.5);
            bgCloudsFar.forEach(cloud => cloud.speed = speed / 3);

            if (player.jetpackActive) {
                player.jetpackTimer--;
                if (player.jetpackTimer <= 0) {
                    player.jetpackActive = false;
                    player.gravity = 0.8;
                } else {
                    player.velocityY -= 0.5;
                }
            }

            player.velocityY += player.gravity;
            player.y += player.velocityY;

            // Val detectie en game over als onder scherm
            if (player.y > canvas.height) {
                gameOver = true;
            }

            if (player.y + player.height >= groundY && !player.jetpackActive && !player.isFalling) {
                player.y = groundY - player.height;
                player.velocityY = 0;
                player.isJumping = false;
            }

            groundOffset -= speed;

            obstacles.forEach(obs => obs.x -= speed);
            items.forEach(item => item.x -= speed);

            obstacles = obstacles.filter(obs => obs.x + obs.width > 0);
            items = items.filter(item => item.x + item.size > 0);

            if (frameCount % obstacleSpawnRate === 0) {
                generateObstacle();
                if (Math.random() > 0.5) generateItem();
                obstacleSpawnRate = Math.max(50, obstacleSpawnRate - 1);
            }

            // Botsingen
            obstacles.forEach(obs => {
                if (obs.type === 'chimney') {
                    if (player.x + player.width > obs.x && player.x < obs.x + obs.width &&
                        player.y + player.height > obs.y && player.y < obs.y + obs.height) {
                        gameOver = true;
                    }
                } else if (obs.type === 'gap') {
                    if (player.x + player.width > obs.x && player.x < obs.x + obs.width &&
                        player.y + player.height >= groundY - 5) { // Nabij ground
                        player.isFalling = true;
                        player.gravity = 1.5;
                        player.velocityY += 2; // Extra val snelheid
                        player.isJumping = false; // Voorkom springen tijdens val
                    }
                }
            });

            // Verzamel items (zelfde)
            items.forEach(item => {
                if (!item.collected && player.x + player.width > item.x && player.x < item.x + item.size &&
                    player.y + player.height > item.y && player.y < item.y + item.size) {
                    item.collected = true;
                    if (item.type === 'money') {
                        money += 10;
                        document.getElementById('money').innerText = 'Geld: €' + money;
                    } else if (item.type === 'jetpack') {
                        player.jetpackActive = true;
                        player.jetpackTimer = 300;
                        player.gravity = -0.2;
                    }
                }
            });

            score += 1;
            document.getElementById('score').innerText = 'Score: ' + score;
        }

        // Draw
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawBackground();
            drawGround();
            drawObstacles();
            drawItems();
            drawPlayer();
        }

        // Loop
        function gameLoop() {
            update();
            draw();
            if (gameOver) {
                document.getElementById('final-score').innerText = score;
                document.getElementById('final-money').innerText = money;
                if (score > highScore) highScore = score;
                document.getElementById('high-score').innerText = highScore;
                document.getElementById('game-over').style.display = 'block';
            }
            requestAnimationFrame(gameLoop);
        }

        // Events
        window.addEventListener('keydown', e => {
            if (e.key === ' ' && !player.isJumping && !player.isFalling) {
                player.velocityY = player.jumpForce;
                player.isJumping = true;
            }
            if (e.key === ' ' && gameOver) resetGame();
        });

        canvas.addEventListener('touchstart', () => {
            if (!player.isJumping && !player.isFalling) {
                player.velocityY = player.jumpForce;
                player.isJumping = true;
            }
            if (gameOver) resetGame();
        });

        // Reset
        function resetGame() {
            player.y = groundY - player.height;
            player.velocityY = 0;
            player.isJumping = false;
            player.jetpackActive = false;
            player.gravity = 0.8;
            player.isFalling = false;
            obstacles = [];
            items = [];
            frameCount = 0;
            score = 0;
            money = 0;
            speed = 5;
            obstacleSpawnRate = 100;
            groundOffset = 0;
            gameOver = false;
            document.getElementById('game-over').style.display = 'none';
            document.getElementById('money').innerText = 'Geld: €0';
        }

        // Start
        resetGame();
        gameLoop();
    </script>
</body>
</html>
